{"version":3,"file":"alpine-auto-animate.min.js","sources":["../node_modules/@formkit/auto-animate/index.mjs","../src/index.js","../builds/cdn.js"],"sourcesContent":["/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */\nconst parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */\nconst coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */\nconst siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */\nconst animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */\nconst intersections = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */\nconst intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */\nconst options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */\nconst debounces = new WeakMap();\n/**\n * All parents that are currently enabled are tracked here.\n */\nconst enabled = new WeakSet();\n/**\n * The document used to calculate transitions.\n */\nlet root;\n/**\n * Used to sign an element as the target.\n */\nconst TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */\nconst DEL = \"__aa_del\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */\nconst handleMutations = (mutations) => {\n    const elements = getElements(mutations);\n    // If elements is \"false\" that means this mutation that should be ignored.\n    if (elements) {\n        elements.forEach((el) => animate(el));\n    }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */\nconst handleResizes = (entries) => {\n    entries.forEach((entry) => {\n        if (entry.target === root)\n            updateAllPos();\n        if (coords.has(entry.target))\n            updatePos(entry.target);\n    });\n};\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */\nfunction observePosition(el) {\n    const oldObserver = intersections.get(el);\n    oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n    let rect = coords.get(el);\n    let invocations = 0;\n    const buffer = 5;\n    if (!rect) {\n        rect = getCoords(el);\n        coords.set(el, rect);\n    }\n    const { offsetWidth, offsetHeight } = root;\n    const rootMargins = [\n        rect.top - buffer,\n        offsetWidth - (rect.left + buffer + rect.width),\n        offsetHeight - (rect.top + buffer + rect.height),\n        rect.left - buffer,\n    ];\n    const rootMargin = rootMargins\n        .map((px) => `${-1 * Math.floor(px)}px`)\n        .join(\" \");\n    const observer = new IntersectionObserver(() => {\n        ++invocations > 1 && updatePos(el);\n    }, {\n        root,\n        threshold: 1,\n        rootMargin,\n    });\n    observer.observe(el);\n    intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n */\nfunction updatePos(el) {\n    clearTimeout(debounces.get(el));\n    const optionsOrPlugin = getOptions(el);\n    const delay = typeof optionsOrPlugin === \"function\" ? 500 : optionsOrPlugin.duration;\n    debounces.set(el, setTimeout(async () => {\n        const currentAnimation = animations.get(el);\n        if (!currentAnimation || (await currentAnimation.finished)) {\n            coords.set(el, getCoords(el));\n            observePosition(el);\n        }\n    }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */\nfunction updateAllPos() {\n    clearTimeout(debounces.get(root));\n    debounces.set(root, setTimeout(() => {\n        parents.forEach((parent) => forEach(parent, (el) => lowPriority(() => updatePos(el))));\n    }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */\nfunction poll(el) {\n    setTimeout(() => {\n        intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2000));\n    }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */\nfunction lowPriority(callback) {\n    if (typeof requestIdleCallback === \"function\") {\n        requestIdleCallback(() => callback());\n    }\n    else {\n        requestAnimationFrame(() => callback());\n    }\n}\n/**\n * The mutation observer responsible for watching each root element.\n */\nlet mutations;\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */\nlet resize;\n/**\n * If this is in a browser, initialize our Web APIs\n */\nif (typeof window !== \"undefined\") {\n    root = document.documentElement;\n    mutations = new MutationObserver(handleMutations);\n    resize = new ResizeObserver(handleResizes);\n    resize.observe(root);\n}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */\nfunction getElements(mutations) {\n    return mutations.reduce((elements, mutation) => {\n        // Short circuit if we find a purposefully deleted node.\n        if (elements === false)\n            return false;\n        if (mutation.target instanceof Element) {\n            target(mutation.target);\n            if (!elements.has(mutation.target)) {\n                elements.add(mutation.target);\n                for (let i = 0; i < mutation.target.children.length; i++) {\n                    const child = mutation.target.children.item(i);\n                    if (!child)\n                        continue;\n                    if (DEL in child)\n                        return false;\n                    target(mutation.target, child);\n                    elements.add(child);\n                }\n            }\n            if (mutation.removedNodes.length) {\n                for (let i = 0; i < mutation.removedNodes.length; i++) {\n                    const child = mutation.removedNodes[i];\n                    if (DEL in child)\n                        return false;\n                    if (child instanceof Element) {\n                        elements.add(child);\n                        target(mutation.target, child);\n                        siblings.set(child, [\n                            mutation.previousSibling,\n                            mutation.nextSibling,\n                        ]);\n                    }\n                }\n            }\n        }\n        return elements;\n    }, new Set());\n}\n/**\n * Assign the target to an element.\n * @param el - The root element\n * @param child\n */\nfunction target(el, child) {\n    if (!child && !(TGT in el))\n        Object.defineProperty(el, TGT, { value: el });\n    else if (child && !(TGT in child))\n        Object.defineProperty(child, TGT, { value: el });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */\nfunction animate(el) {\n    var _a;\n    const isMounted = root.contains(el);\n    const preExisting = coords.has(el);\n    if (isMounted && siblings.has(el))\n        siblings.delete(el);\n    if (animations.has(el)) {\n        (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();\n    }\n    if (preExisting && isMounted) {\n        remain(el);\n    }\n    else if (preExisting && !isMounted) {\n        remove(el);\n    }\n    else {\n        add(el);\n    }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */\nfunction raw(str) {\n    return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */\nfunction getCoords(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        left: rect.left + window.scrollX,\n        width: rect.width,\n        height: rect.height,\n    };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */\nfunction getTransitionSizes(el, oldCoords, newCoords) {\n    let widthFrom = oldCoords.width;\n    let heightFrom = oldCoords.height;\n    let widthTo = newCoords.width;\n    let heightTo = newCoords.height;\n    const styles = getComputedStyle(el);\n    const sizing = styles.getPropertyValue(\"box-sizing\");\n    if (sizing === \"content-box\") {\n        const paddingY = raw(styles.paddingTop) +\n            raw(styles.paddingBottom) +\n            raw(styles.borderTopWidth) +\n            raw(styles.borderBottomWidth);\n        const paddingX = raw(styles.paddingLeft) +\n            raw(styles.paddingRight) +\n            raw(styles.borderRightWidth) +\n            raw(styles.borderLeftWidth);\n        widthFrom -= paddingX;\n        widthTo -= paddingX;\n        heightFrom -= paddingY;\n        heightTo -= paddingY;\n    }\n    return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */\nfunction getOptions(el) {\n    return TGT in el && options.has(el[TGT])\n        ? options.get(el[TGT])\n        : { duration: 250, easing: \"ease-in-out\" };\n}\n/**\n * Returns the target of a given animation (generally the parent).\n * @param el - An element to check for a target\n * @returns\n */\nfunction getTarget(el) {\n    if (TGT in el)\n        return el[TGT];\n    return undefined;\n}\n/**\n * Checks if animations are enabled or disabled for a given element.\n * @param el - Any element\n * @returns\n */\nfunction isEnabled(el) {\n    const target = getTarget(el);\n    return target ? enabled.has(target) : false;\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */\nfunction forEach(parent, ...callbacks) {\n    callbacks.forEach((callback) => callback(parent, options.has(parent)));\n    for (let i = 0; i < parent.children.length; i++) {\n        const child = parent.children.item(i);\n        if (child) {\n            callbacks.forEach((callback) => callback(child, options.has(child)));\n        }\n    }\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */\nfunction remain(el) {\n    const oldCoords = coords.get(el);\n    const newCoords = getCoords(el);\n    if (!isEnabled(el))\n        return coords.set(el, newCoords);\n    let animation;\n    if (!oldCoords)\n        return;\n    const pluginOrOptions = getOptions(el);\n    if (typeof pluginOrOptions !== \"function\") {\n        const deltaX = oldCoords.left - newCoords.left;\n        const deltaY = oldCoords.top - newCoords.top;\n        const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n        const start = {\n            transform: `translate(${deltaX}px, ${deltaY}px)`,\n        };\n        const end = {\n            transform: `translate(0, 0)`,\n        };\n        if (widthFrom !== widthTo) {\n            start.width = `${widthFrom}px`;\n            end.width = `${widthTo}px`;\n        }\n        if (heightFrom !== heightTo) {\n            start.height = `${heightFrom}px`;\n            end.height = `${heightTo}px`;\n        }\n        animation = el.animate([start, end], {\n            duration: pluginOrOptions.duration,\n            easing: pluginOrOptions.easing,\n        });\n    }\n    else {\n        animation = new Animation(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n        animation.play();\n    }\n    animations.set(el, animation);\n    coords.set(el, newCoords);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */\nfunction add(el) {\n    const newCoords = getCoords(el);\n    coords.set(el, newCoords);\n    const pluginOrOptions = getOptions(el);\n    if (!isEnabled(el))\n        return;\n    let animation;\n    if (typeof pluginOrOptions !== \"function\") {\n        animation = el.animate([\n            { transform: \"scale(.98)\", opacity: 0 },\n            { transform: \"scale(0.98)\", opacity: 0, offset: 0.5 },\n            { transform: \"scale(1)\", opacity: 1 },\n        ], {\n            duration: pluginOrOptions.duration * 1.5,\n            easing: \"ease-in\",\n        });\n    }\n    else {\n        animation = new Animation(pluginOrOptions(el, \"add\", newCoords));\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */\nfunction remove(el) {\n    var _a;\n    if (!siblings.has(el) || !coords.has(el))\n        return;\n    const [prev, next] = siblings.get(el);\n    Object.defineProperty(el, DEL, { value: true });\n    if (next && next.parentNode && next.parentNode instanceof Element) {\n        next.parentNode.insertBefore(el, next);\n    }\n    else if (prev && prev.parentNode) {\n        prev.parentNode.appendChild(el);\n    }\n    else {\n        (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);\n    }\n    function cleanUp() {\n        var _a;\n        el.remove();\n        coords.delete(el);\n        siblings.delete(el);\n        animations.delete(el);\n        (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n    }\n    if (!isEnabled(el))\n        return cleanUp();\n    const [top, left, width, height] = deletePosition(el);\n    const optionsOrPlugin = getOptions(el);\n    const oldCoords = coords.get(el);\n    let animation;\n    Object.assign(el.style, {\n        position: \"absolute\",\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        margin: 0,\n        pointerEvents: \"none\",\n        transformOrigin: \"center\",\n        zIndex: 100,\n    });\n    if (typeof optionsOrPlugin !== \"function\") {\n        animation = el.animate([\n            {\n                transform: \"scale(1)\",\n                opacity: 1,\n            },\n            {\n                transform: \"scale(.98)\",\n                opacity: 0,\n            },\n        ], { duration: optionsOrPlugin.duration, easing: \"ease-out\" });\n    }\n    else {\n        animation = new Animation(optionsOrPlugin(el, \"remove\", oldCoords));\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", cleanUp);\n}\nfunction deletePosition(el) {\n    const oldCoords = coords.get(el);\n    const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));\n    let offsetParent = el.parentElement;\n    while (offsetParent &&\n        (getComputedStyle(offsetParent).position === \"static\" ||\n            offsetParent instanceof HTMLBodyElement)) {\n        offsetParent = offsetParent.parentElement;\n    }\n    if (!offsetParent)\n        offsetParent = document.body;\n    const parentStyles = getComputedStyle(offsetParent);\n    const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);\n    const top = Math.round(oldCoords.top - parentCoords.top) -\n        raw(parentStyles.borderTopWidth);\n    const left = Math.round(oldCoords.left - parentCoords.left) -\n        raw(parentStyles.borderLeftWidth);\n    return [top, left, width, height];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */\nfunction autoAnimate(el, config = {}) {\n    if (mutations && resize) {\n        const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n        const isDisabledDueToReduceMotion = mediaQuery.matches &&\n            typeof config !== \"function\" &&\n            !config.disrespectUserMotionPreference;\n        if (!isDisabledDueToReduceMotion) {\n            enabled.add(el);\n            if (getComputedStyle(el).position === \"static\") {\n                Object.assign(el.style, { position: \"relative\" });\n            }\n            forEach(el, updatePos, poll, (element) => resize === null || resize === void 0 ? void 0 : resize.observe(element));\n            if (typeof config === \"function\") {\n                options.set(el, config);\n            }\n            else {\n                options.set(el, { duration: 250, easing: \"ease-in-out\", ...config });\n            }\n            mutations.observe(el, { childList: true });\n            parents.add(el);\n        }\n    }\n    return Object.freeze({\n        parent: el,\n        enable: () => {\n            enabled.add(el);\n        },\n        disable: () => {\n            enabled.delete(el);\n        },\n        isEnabled: () => enabled.has(el),\n    });\n}\n/**\n * The vue directive.\n */\nconst vAutoAnimate = {\n    mounted: (el, binding) => {\n        autoAnimate(el, binding.value || {});\n    },\n};\n\nexport { autoAnimate as default, getTransitionSizes, vAutoAnimate };\n","import autoAnimate from '@formkit/auto-animate';\n\nlet autoAnimateConfig = {};\n\nfunction AutoAnimate(Alpine) {\n    Alpine.directive('auto-animate', (el, { expression, modifiers }, { evaluateLater, effect }) => {\n        let config = {};\n        const durationModifier = modifiers.filter((modifier) => modifier.match(/^\\d+m?s$/))[0] || null;\n        if (durationModifier) {\n            const inMilliseconds = !!durationModifier.match(/ms$/);\n            const matchedDuration = + durationModifier.match(/^\\d+/);\n            config.duration = matchedDuration * (inMilliseconds ? 1 : 1000);\n        }\n        const easingModifier = modifiers.filter((modifier) => !modifier.match(/^\\d+m?s$/))[0] || null;\n        if (easingModifier) {\n            config.easing = easingModifier;\n        }\n        const controller = autoAnimate(el, { ...autoAnimateConfig, ...config });\n        if (expression) {\n            const isEnabled = evaluateLater(expression);\n            effect(() => {\n                isEnabled((enabled) => {\n                    if (enabled) {\n                        controller.enable();\n                    } else {\n                        controller.disable();\n                    }\n                });\n            })\n        }\n    });\n}\n\nAutoAnimate.configure = (config) => {\n    autoAnimateConfig = config;\n};\n\nexport default AutoAnimate;\n","import AutoAnimate from \"../src/index.js\";\n\ndocument.addEventListener('alpine:init', () => {\n    AutoAnimate(window.Alpine);\n});\n"],"names":["parents","Set","coords","WeakMap","siblings","animations","intersections","intervals","options","debounces","enabled","WeakSet","root","TGT","DEL","handleMutations","mutations","elements","reduce","mutation","target","Element","has","add","i","children","length","child","item","removedNodes","set","previousSibling","nextSibling","getElements","forEach","el","_a","isMounted","contains","preExisting","delete","get","cancel","oldCoords","newCoords","getCoords","isEnabled","animation","pluginOrOptions","getOptions","deltaX","left","deltaY","top","widthFrom","widthTo","heightFrom","heightTo","getTransitionSizes","start","transform","end","width","height","animate","duration","easing","Animation","play","addEventListener","updatePos","bind","remain","prev","next","Object","defineProperty","value","parentNode","insertBefore","appendChild","getTarget","cleanUp","remove","disconnect","offsetParent","parentElement","getComputedStyle","position","HTMLBodyElement","document","body","parentStyles","parentCoords","Math","round","raw","borderTopWidth","borderLeftWidth","deletePosition","optionsOrPlugin","assign","style","margin","pointerEvents","transformOrigin","zIndex","opacity","offset","handleResizes","entries","entry","clearTimeout","setTimeout","parent","lowPriority","delay","async","currentAnimation","finished","oldObserver","rect","invocations","offsetWidth","offsetHeight","rootMargin","map","px","floor","join","observer","IntersectionObserver","threshold","observe","observePosition","poll","setInterval","random","callback","requestIdleCallback","requestAnimationFrame","resize","str","Number","replace","getBoundingClientRect","window","scrollY","scrollX","styles","getPropertyValue","paddingY","paddingTop","paddingBottom","borderBottomWidth","paddingX","paddingLeft","paddingRight","borderRightWidth","callbacks","documentElement","MutationObserver","ResizeObserver","autoAnimateConfig","AutoAnimate","Alpine","directive","expression","modifiers","evaluateLater","effect","config","durationModifier","filter","modifier","match","inMilliseconds","matchedDuration","easingModifier","controller","matchMedia","matches","disrespectUserMotionPreference","element","childList","freeze","enable","disable","autoAnimate","configure"],"mappings":"2FAIA,MAAMA,EAAU,IAAIC,IAIdC,EAAS,IAAIC,QAIbC,EAAW,IAAID,QAIfE,EAAa,IAAIF,QAIjBG,EAAgB,IAAIH,QAIpBI,EAAY,IAAIJ,QAIhBK,EAAU,IAAIL,QAIdM,EAAY,IAAIN,QAIhBO,EAAU,IAAIC,QAIpB,IAAIC,EAIJ,MAAMC,EAAM,WAINC,EAAM,WAKNC,EAAmBC,IACrB,MAAMC,EA6HV,SAAqBD,GACjB,OAAOA,EAAUE,QAAO,CAACD,EAAUE,KAE/B,IAAiB,IAAbF,EACA,OAAO,EACX,GAAIE,EAASC,kBAAkBC,QAAS,CAEpC,GADAD,EAAOD,EAASC,SACXH,EAASK,IAAIH,EAASC,QAAS,CAChCH,EAASM,IAAIJ,EAASC,QACtB,IAAK,IAAII,EAAI,EAAGA,EAAIL,EAASC,OAAOK,SAASC,OAAQF,IAAK,CACtD,MAAMG,EAAQR,EAASC,OAAOK,SAASG,KAAKJ,GAC5C,GAAKG,EAAL,CAEA,GAAIb,KAAOa,EACP,OAAO,EACXP,EAAOD,EAASC,OAAQO,GACxBV,EAASM,IAAII,EAJA,CAKhB,CACJ,CACD,GAAIR,EAASU,aAAaH,OACtB,IAAK,IAAIF,EAAI,EAAGA,EAAIL,EAASU,aAAaH,OAAQF,IAAK,CACnD,MAAMG,EAAQR,EAASU,aAAaL,GACpC,GAAIV,KAAOa,EACP,OAAO,EACPA,aAAiBN,UACjBJ,EAASM,IAAII,GACbP,EAAOD,EAASC,OAAQO,GACxBvB,EAAS0B,IAAIH,EAAO,CAChBR,EAASY,gBACTZ,EAASa,cAGpB,CAER,CACD,OAAOf,CAAQ,GAChB,IAAIhB,IACX,CAlKqBgC,CAAYjB,GAEzBC,GACAA,EAASiB,SAASC,GAgL1B,SAAiBA,GACb,IAAIC,EACJ,MAAMC,EAAYzB,EAAK0B,SAASH,GAC1BI,EAAcrC,EAAOoB,IAAIa,GAC3BE,GAAajC,EAASkB,IAAIa,IAC1B/B,EAASoC,OAAOL,GAChB9B,EAAWiB,IAAIa,KACe,QAA7BC,EAAK/B,EAAWoC,IAAIN,UAAwB,IAAPC,GAAyBA,EAAGM,UAElEH,GAAeF,EA+GvB,SAAgBF,GACZ,MAAMQ,EAAYzC,EAAOuC,IAAIN,GACvBS,EAAYC,EAAUV,GAC5B,IAAKW,EAAUX,GACX,OAAOjC,EAAO4B,IAAIK,EAAIS,GAC1B,IAAIG,EACJ,IAAKJ,EACD,OACJ,MAAMK,EAAkBC,EAAWd,GACnC,GAA+B,mBAApBa,EAAgC,CACvC,MAAME,EAASP,EAAUQ,KAAOP,EAAUO,KACpCC,EAAST,EAAUU,IAAMT,EAAUS,KAClCC,EAAWC,EAASC,EAAYC,GAAYC,EAAmBvB,EAAIQ,EAAWC,GAC/Ee,EAAQ,CACVC,UAAW,aAAaV,QAAaE,QAEnCS,EAAM,CACRD,UAAW,mBAEXN,IAAcC,IACdI,EAAMG,MAAQ,GAAGR,MACjBO,EAAIC,MAAQ,GAAGP,OAEfC,IAAeC,IACfE,EAAMI,OAAS,GAAGP,MAClBK,EAAIE,OAAS,GAAGN,OAEpBV,EAAYZ,EAAG6B,QAAQ,CAACL,EAAOE,GAAM,CACjCI,SAAUjB,EAAgBiB,SAC1BC,OAAQlB,EAAgBkB,QAE/B,MAEGnB,EAAY,IAAIoB,UAAUnB,EAAgBb,EAAI,SAAUQ,EAAWC,IACnEG,EAAUqB,OAEd/D,EAAWyB,IAAIK,EAAIY,GACnB7C,EAAO4B,IAAIK,EAAIS,GACfG,EAAUsB,iBAAiB,SAAUC,EAAUC,KAAK,KAAMpC,GAC9D,CArJQqC,CAAOrC,GAEFI,IAAgBF,EAoL7B,SAAgBF,GACZ,IAAIC,EACJ,IAAKhC,EAASkB,IAAIa,KAAQjC,EAAOoB,IAAIa,GACjC,OACJ,MAAOsC,EAAMC,GAAQtE,EAASqC,IAAIN,GAClCwC,OAAOC,eAAezC,EAAIrB,EAAK,CAAE+D,OAAO,IACpCH,GAAQA,EAAKI,YAAcJ,EAAKI,sBAAsBzD,QACtDqD,EAAKI,WAAWC,aAAa5C,EAAIuC,GAE5BD,GAAQA,EAAKK,WAClBL,EAAKK,WAAWE,YAAY7C,GAGH,QAAxBC,EAAK6C,EAAU9C,UAAwB,IAAPC,GAAyBA,EAAG4C,YAAY7C,GAE7E,SAAS+C,IACL,IAAI9C,EACJD,EAAGgD,SACHjF,EAAOsC,OAAOL,GACd/B,EAASoC,OAAOL,GAChB9B,EAAWmC,OAAOL,GACe,QAAhCC,EAAK9B,EAAcmC,IAAIN,UAAwB,IAAPC,GAAyBA,EAAGgD,YACxE,CACD,IAAKtC,EAAUX,GACX,OAAO+C,IACX,MAAO7B,EAAKF,EAAMW,EAAOC,GAkC7B,SAAwB5B,GACpB,MAAMQ,EAAYzC,EAAOuC,IAAIN,IACtB2B,GAASC,GAAUL,EAAmBvB,EAAIQ,EAAWE,EAAUV,IACtE,IAAIkD,EAAelD,EAAGmD,cACtB,KAAOD,IAC0C,WAA5CE,iBAAiBF,GAAcG,UAC5BH,aAAwBI,kBAC5BJ,EAAeA,EAAaC,cAE3BD,IACDA,EAAeK,SAASC,MAC5B,MAAMC,EAAeL,iBAAiBF,GAChCQ,EAAe3F,EAAOuC,IAAI4C,IAAiBxC,EAAUwC,GACrDhC,EAAMyC,KAAKC,MAAMpD,EAAUU,IAAMwC,EAAaxC,KAChD2C,EAAIJ,EAAaK,gBACf9C,EAAO2C,KAAKC,MAAMpD,EAAUQ,KAAO0C,EAAa1C,MAClD6C,EAAIJ,EAAaM,iBACrB,MAAO,CAAC7C,EAAKF,EAAMW,EAAOC,EAC9B,CApDuCoC,CAAehE,GAC5CiE,EAAkBnD,EAAWd,GAC7BQ,EAAYzC,EAAOuC,IAAIN,GAC7B,IAAIY,EACJ4B,OAAO0B,OAAOlE,EAAGmE,MAAO,CACpBd,SAAU,WACVnC,IAAK,GAAGA,MACRF,KAAM,GAAGA,MACTW,MAAO,GAAGA,MACVC,OAAQ,GAAGA,MACXwC,OAAQ,EACRC,cAAe,OACfC,gBAAiB,SACjBC,OAAQ,MAEmB,mBAApBN,EACPrD,EAAYZ,EAAG6B,QAAQ,CACnB,CACIJ,UAAW,WACX+C,QAAS,GAEb,CACI/C,UAAW,aACX+C,QAAS,IAEd,CAAE1C,SAAUmC,EAAgBnC,SAAUC,OAAQ,cAGjDnB,EAAY,IAAIoB,UAAUiC,EAAgBjE,EAAI,SAAUQ,IACxDI,EAAUqB,QAEd/D,EAAWyB,IAAIK,EAAIY,GACnBA,EAAUsB,iBAAiB,SAAUa,EACzC,CA7OQC,CAAOhD,GAuJf,SAAaA,GACT,MAAMS,EAAYC,EAAUV,GAC5BjC,EAAO4B,IAAIK,EAAIS,GACf,MAAMI,EAAkBC,EAAWd,GACnC,IAAKW,EAAUX,GACX,OACJ,IAAIY,EAC2B,mBAApBC,EACPD,EAAYZ,EAAG6B,QAAQ,CACnB,CAAEJ,UAAW,aAAc+C,QAAS,GACpC,CAAE/C,UAAW,cAAe+C,QAAS,EAAGC,OAAQ,IAChD,CAAEhD,UAAW,WAAY+C,QAAS,IACnC,CACC1C,SAAqC,IAA3BjB,EAAgBiB,SAC1BC,OAAQ,aAIZnB,EAAY,IAAIoB,UAAUnB,EAAgBb,EAAI,MAAOS,IACrDG,EAAUqB,QAEd/D,EAAWyB,IAAIK,EAAIY,GACnBA,EAAUsB,iBAAiB,SAAUC,EAAUC,KAAK,KAAMpC,GAC9D,CA3KQZ,CAAIY,EAEZ,CAlMiC6B,CAAQ7B,IACpC,EAMC0E,EAAiBC,IACnBA,EAAQ5E,SAAS6E,IACTA,EAAM3F,SAAWR,IA4DzBoG,aAAavG,EAAUgC,IAAI7B,IAC3BH,EAAUqB,IAAIlB,EAAMqG,YAAW,KAC3BjH,EAAQkC,SAASgF,GAAWhF,EAAQgF,GAAS/E,GAAOgF,GAAY,IAAM7C,EAAUnC,QAAM,GACvF,OA7DKjC,EAAOoB,IAAIyF,EAAM3F,SACjBkD,EAAUyC,EAAM3F,OAAO,GAC7B,EAwCN,SAASkD,EAAUnC,GACf6E,aAAavG,EAAUgC,IAAIN,IAC3B,MAAMiE,EAAkBnD,EAAWd,GAC7BiF,EAAmC,mBAApBhB,EAAiC,IAAMA,EAAgBnC,SAC5ExD,EAAUqB,IAAIK,EAAI8E,YAAWI,UACzB,MAAMC,EAAmBjH,EAAWoC,IAAIN,GACnCmF,UAA2BA,EAAiBC,WAC7CrH,EAAO4B,IAAIK,EAAIU,EAAUV,IAzCrC,SAAyBA,GACrB,MAAMqF,EAAclH,EAAcmC,IAAIN,GACtCqF,SAA0DA,EAAYpC,aACtE,IAAIqC,EAAOvH,EAAOuC,IAAIN,GAClBuF,EAAc,EAEbD,IACDA,EAAO5E,EAAUV,GACjBjC,EAAO4B,IAAIK,EAAIsF,IAEnB,MAAME,YAAEA,EAAWC,aAAEA,GAAiBhH,EAOhCiH,EANc,CAChBJ,EAAKpE,IAPM,EAQXsE,GAAeF,EAAKtE,KART,EAQyBsE,EAAK3D,OACzC8D,GAAgBH,EAAKpE,IATV,EASyBoE,EAAK1D,QACzC0D,EAAKtE,KAVM,GAaV2E,KAAKC,IAAW,EAAIjC,KAAKkC,MAAMD,GAAnB,OACZE,KAAK,KACJC,EAAW,IAAIC,sBAAqB,OACpCT,EAAc,GAAKpD,EAAUnC,EAAG,GACnC,CACCvB,OACAwH,UAAW,EACXP,eAEJK,EAASG,QAAQlG,GACjB7B,EAAcwB,IAAIK,EAAI+F,EAC1B,CAaYI,CAAgBnG,GACnB,GACFiF,GACP,CAkBA,SAASmB,EAAKpG,GACV8E,YAAW,KACP1G,EAAUuB,IAAIK,EAAIqG,aAAY,IAAMrB,EAAY7C,EAAUC,KAAK,KAAMpC,KAAM,KAAM,GAClF2D,KAAKC,MAAM,IAAOD,KAAK2C,UAC9B,CAKA,SAAStB,EAAYuB,GACkB,mBAAxBC,oBACPA,qBAAoB,IAAMD,MAG1BE,uBAAsB,IAAMF,KAEpC,CAIA,IAAI1H,EAIA6H,EA2DJ,SAASzH,EAAOe,EAAIR,GACXA,GAAWd,KAAOsB,EAEdR,KAAWd,KAAOc,IACvBgD,OAAOC,eAAejD,EAAOd,EAAK,CAAEgE,MAAO1C,IAF3CwC,OAAOC,eAAezC,EAAItB,EAAK,CAAEgE,MAAO1C,GAGhD,CA8BA,SAAS6D,EAAI8C,GACT,OAAOC,OAAOD,EAAIE,QAAQ,aAAc,IAC5C,CAMA,SAASnG,EAAUV,GACf,MAAMsF,EAAOtF,EAAG8G,wBAChB,MAAO,CACH5F,IAAKoE,EAAKpE,IAAM6F,OAAOC,QACvBhG,KAAMsE,EAAKtE,KAAO+F,OAAOE,QACzBtF,MAAO2D,EAAK3D,MACZC,OAAQ0D,EAAK1D,OAErB,CASA,SAASL,EAAmBvB,EAAIQ,EAAWC,GACvC,IAAIU,EAAYX,EAAUmB,MACtBN,EAAab,EAAUoB,OACvBR,EAAUX,EAAUkB,MACpBL,EAAWb,EAAUmB,OACzB,MAAMsF,EAAS9D,iBAAiBpD,GAEhC,GAAe,gBADAkH,EAAOC,iBAAiB,cACT,CAC1B,MAAMC,EAAWvD,EAAIqD,EAAOG,YACxBxD,EAAIqD,EAAOI,eACXzD,EAAIqD,EAAOpD,gBACXD,EAAIqD,EAAOK,mBACTC,EAAW3D,EAAIqD,EAAOO,aACxB5D,EAAIqD,EAAOQ,cACX7D,EAAIqD,EAAOS,kBACX9D,EAAIqD,EAAOnD,iBACf5C,GAAaqG,EACbpG,GAAWoG,EACXnG,GAAc+F,EACd9F,GAAY8F,CACf,CACD,MAAO,CAACjG,EAAWC,EAASC,EAAYC,GAAUqE,IAAIhC,KAAKC,MAC/D,CAMA,SAAS9C,EAAWd,GAChB,OAAOtB,KAAOsB,GAAM3B,EAAQc,IAAIa,EAAGtB,IAC7BL,EAAQiC,IAAIN,EAAGtB,IACf,CAAEoD,SAAU,IAAKC,OAAQ,cACnC,CAMA,SAASe,EAAU9C,GACf,GAAItB,KAAOsB,EACP,OAAOA,EAAGtB,EAElB,CAMA,SAASiC,EAAUX,GACf,MAAMf,EAAS6D,EAAU9C,GACzB,QAAOf,GAASV,EAAQY,IAAIF,EAChC,CAMA,SAASc,EAAQgF,KAAW6C,GACxBA,EAAU7H,SAASwG,GAAaA,EAASxB,EAAQ1G,EAAQc,IAAI4F,MAC7D,IAAK,IAAI1F,EAAI,EAAGA,EAAI0F,EAAOzF,SAASC,OAAQF,IAAK,CAC7C,MAAMG,EAAQuF,EAAOzF,SAASG,KAAKJ,GAC/BG,GACAoI,EAAU7H,SAASwG,GAAaA,EAAS/G,EAAOnB,EAAQc,IAAIK,KAEnE,CACL,CApLsB,oBAAXuH,SACPtI,EAAO8E,SAASsE,gBAChBhJ,EAAY,IAAIiJ,iBAAiBlJ,GACjC8H,EAAS,IAAIqB,eAAerD,GAC5BgC,EAAOR,QAAQzH,ICzKnB,IAAIuJ,EAAoB,CAAA,EAExB,SAASC,EAAYC,GACjBA,EAAOC,UAAU,gBAAgB,CAACnI,GAAMoI,aAAYC,cAAeC,gBAAeC,aAC9E,IAAIC,EAAS,CAAA,EACb,MAAMC,EAAmBJ,EAAUK,QAAQC,GAAaA,EAASC,MAAM,cAAa,IAAM,KAC1F,GAAIH,EAAkB,CAClB,MAAMI,IAAmBJ,EAAiBG,MAAM,OAC1CE,GAAoBL,EAAiBG,MAAM,QACjDJ,EAAO1G,SAAWgH,GAAmBD,EAAiB,EAAI,IAC7D,CACD,MAAME,EAAiBV,EAAUK,QAAQC,IAAcA,EAASC,MAAM,cAAa,IAAM,KACrFG,IACAP,EAAOzG,OAASgH,GAEpB,MAAMC,ED6ed,SAAqBhJ,EAAIwI,EAAS,IAC1B3J,GAAa6H,IACMK,OAAOkC,WAAW,oCACUC,SACzB,mBAAXV,IACNA,EAAOW,iCAER5K,EAAQa,IAAIY,GAC0B,WAAlCoD,iBAAiBpD,GAAIqD,UACrBb,OAAO0B,OAAOlE,EAAGmE,MAAO,CAAEd,SAAU,aAExCtD,EAAQC,EAAImC,EAAWiE,GAAOgD,GAAY1C,aAAuC,EAASA,EAAOR,QAAQkD,KACnF,mBAAXZ,EACPnK,EAAQsB,IAAIK,EAAIwI,GAGhBnK,EAAQsB,IAAIK,EAAI,CAAE8B,SAAU,IAAKC,OAAQ,iBAAkByG,IAE/D3J,EAAUqH,QAAQlG,EAAI,CAAEqJ,WAAW,IACnCxL,EAAQuB,IAAIY,KAGpB,OAAOwC,OAAO8G,OAAO,CACjBvE,OAAQ/E,EACRuJ,OAAQ,KACJhL,EAAQa,IAAIY,EAAG,EAEnBwJ,QAAS,KACLjL,EAAQ8B,OAAOL,EAAG,EAEtBW,UAAW,IAAMpC,EAAQY,IAAIa,IAErC,CC7gB2ByJ,CAAYzJ,EAAI,IAAKgI,KAAsBQ,IAC9D,GAAIJ,EAAY,CACZ,MAAMzH,EAAY2H,EAAcF,GAChCG,GAAO,KACH5H,GAAWpC,IACHA,EACAyK,EAAWO,SAEXP,EAAWQ,SACd,GALL,GAQP,IAER,CAEDvB,EAAYyB,UAAalB,IACrBR,EAAoBQ,CAApB,EChCJjF,SAASrB,iBAAiB,eAAe,KACrC+F,EAAYlB,OAAOmB,OAAnB"}